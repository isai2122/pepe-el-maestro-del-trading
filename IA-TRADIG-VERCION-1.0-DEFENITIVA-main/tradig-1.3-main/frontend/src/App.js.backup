import React, { useEffect, useRef, useState, useCallback } from 'react';
import { createChart } from 'lightweight-charts';
import { 
  Activity, 
  TrendingUp, 
  TrendingDown, 
  BarChart3, 
  Target, 
  Brain,
  Zap,
  DollarSign,
  PieChart,
  ArrowUpCircle,
  ArrowDownCircle,
  Minus
} from 'lucide-react';
import './App.css';

const App = () => {
  const pair = 'BTCUSDT';
  const timeframe = '5m';

  const [connected, setConnected] = useState(false);
  const [lastUpdate, setLastUpdate] = useState(null);
  const [marketData, setMarketData] = useState([]);
  const marketRef = useRef([]);
  const wsRef = useRef(null);
  const chartRef = useRef(null);
  const seriesRef = useRef(null);
  const containerRef = useRef(null);

  const [simulations, setSimulations] = useState(() => {
    try {
      const saved = localStorage.getItem('ptai_sims_v1');
      return saved ? JSON.parse(saved) : [];
    } catch {
      return [];
    }
  });

  const [currentPrediction, setCurrentPrediction] = useState(null);
  const [analysis, setAnalysis] = useState(null);
  const [activeTab, setActiveTab] = useState('live');

  // Guardado automático de simulaciones
  useEffect(() => {
    try {
      localStorage.setItem('ptai_sims_v1', JSON.stringify(simulations));
    } catch {}
  }, [simulations]);

  // Cálculo de indicadores técnicos
  const calculateIndicators = useCallback((data) => {
    if (!data || data.length < 26) return null;
    
    const closes = data.map(d => d.close);
    const sma = (arr) => arr.reduce((a, b) => a + b, 0) / (arr.length || 1);
    
    const sma_fast = sma(closes.slice(-5));
    const sma_slow = sma(closes.slice(-20));

    // RSI
    let gains = 0, losses = 0, count = 0;
    for (let i = 1; i < Math.min(closes.length, 15); i++) {
      const ch = closes[closes.length - i] - closes[closes.length - i - 1];
      if (ch > 0) gains += ch;
      else losses += Math.abs(ch);
      count++;
    }
    const avgGain = gains / (count || 1);
    const avgLoss = losses / (count || 1);
    const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
    const rsi = 100 - (100 / (1 + rs));

    // MACD
    const ema = (arr) => arr.reduce((a, b) => a + b, 0) / (arr.length || 1);
    const macd = ema(closes.slice(-12)) - ema(closes.slice(-26));

    // Bollinger Bands
    const sma20 = sma(closes.slice(-20));
    const variance = closes.slice(-20).reduce((s, p) => s + Math.pow(p - sma20, 2), 0) / 20;
    const std = Math.sqrt(variance || 0);
    const upper = sma20 + std * 2;
    const lower = sma20 - std * 2;

    // Volume
    const volumes = data.map(d => d.volume || 0);
    const avgVol = volumes.slice(-10).reduce((a, b) => a + b, 0) / (Math.min(volumes.length, 10) || 1);
    const volRatio = (volumes[volumes.length - 1] || 1) / (avgVol || 1);

    return {
      sma_fast,
      sma_slow,
      rsi,
      macd,
      bollinger: { upper, lower, middle: sma20 },
      volume: { ratio: volRatio },
      price: closes[closes.length - 1]
    };
  }, []);

  // IA de predicción
  const makePrediction = useCallback((indicators) => {
    if (!indicators) return null;

    const weights = { sma_fast: 0.25, rsi: 0.15, macd: 0.15, bollinger: 0.10, volume: 0.10 };
    let signal = 0;
    const reasoning = [];

    if (indicators.sma_fast > indicators.sma_slow) {
      signal += weights.sma_fast * 2;
      reasoning.push('SMA rápida > lenta (Alcista)');
    } else {
      signal -= weights.sma_fast * 2;
      reasoning.push('SMA rápida < lenta (Bajista)');
    }

    if (indicators.rsi > 70) {
      signal -= weights.rsi * 1.5;
      reasoning.push('RSI sobrecomprado (>70)');
    } else if (indicators.rsi < 30) {
      signal += weights.rsi * 1.5;
      reasoning.push('RSI sobrevendido (<30)');
    }

    if (indicators.macd > 0) {
      signal += weights.macd;
      reasoning.push('MACD positivo');
    } else {
      signal -= weights.macd;
      reasoning.push('MACD negativo');
    }

    if (indicators.price > indicators.bollinger.upper) {
      signal -= weights.bollinger;
      reasoning.push('Precio sobre banda superior');
    } else if (indicators.price < indicators.bollinger.lower) {
      signal += weights.bollinger;
      reasoning.push('Precio bajo banda inferior');
    }

    if (indicators.volume?.ratio > 1.5) {
      const vs = signal > 0 ? weights.volume : -weights.volume;
      signal += vs;
      reasoning.push('Volumen alto confirmando movimiento');
    }

    const norm = Math.tanh(signal * 2);
    const up = Math.round(((norm + 1) / 2) * 100);
    const down = 100 - up;
    const trend = up > 65 ? 'UP' : down > 65 ? 'DOWN' : 'NEUTRAL';
    const confidence = Math.abs(norm);

    return {
      trend,
      probability: { up, down },
      confidence,
      reasoning,
      indicators
    };
  }, []);

  // Configuración del gráfico
  useEffect(() => {
    if (!containerRef.current) return;
    
    try {
      containerRef.current.innerHTML = '';
    } catch {}

    const chart = createChart(containerRef.current, {
      width: containerRef.current.clientWidth,
      height: 600,
      layout: {
        background: { color: '#0a0e1a' },
        textColor: '#64748b'
      },
      grid: {
        vertLines: { color: '#1e293b' },
        horzLines: { color: '#1e293b' }
      },
      crosshair: {
        mode: 1,
        vertLine: {
          color: '#3b82f6',
          width: 1,
          style: 2
        },
        horzLine: {
          color: '#3b82f6',
          width: 1,
          style: 2
        }
      },
      timeScale: {
        timeVisible: true,
        secondsVisible: false,
        borderColor: '#1e293b'
      },
      rightPriceScale: {
        borderColor: '#1e293b'
      }
    });

    const candlestickSeries = chart.addCandlestickSeries({
      upColor: '#10b981',
      downColor: '#ef4444',
      borderDownColor: '#ef4444',
      borderUpColor: '#10b981',
      wickDownColor: '#ef4444',
      wickUpColor: '#10b981'
    });

    chartRef.current = chart;
    seriesRef.current = candlestickSeries;

    const resize = () => {
      if (containerRef.current) {
        chart.applyOptions({ width: containerRef.current.clientWidth });
      }
    };

    window.addEventListener('resize', resize);
    return () => window.removeEventListener('resize', resize);
  }, []);

  // Actualización de datos del gráfico
  useEffect(() => {
    if (!seriesRef.current || !marketData.length) return;
    
    const data = marketData.map(d => ({
      time: Math.floor(d.time / 1000),
      open: d.open,
      high: d.high,
      low: d.low,
      close: d.close
    }));

    try {
      seriesRef.current.setData(data);
    } catch (e) {
      console.error('Error updating chart:', e);
    }
  }, [marketData]);

  const generateSyntheticData = useCallback(() => {
    const data = [];
    const now = Date.now();
    let price = 65000; // BTC price base
    
    for (let i = 500; i > 0; i--) {
      const time = now - (i * 5 * 60 * 1000); // 5 minutes intervals
      const change = (Math.random() - 0.5) * 1000; // ±500 price change
      const open = price;
      const close = Math.max(1000, price + change);
      const high = Math.max(open, close) + Math.random() * 200;
      const low = Math.min(open, close) - Math.random() * 200;
      const volume = 100 + Math.random() * 500;
      
      data.push({
        time,
        open,
        high,
        low,
        close,
        volume,
        timestamp: new Date(time).toLocaleString()
      });
      
      price = close;
    }
    
    setMarketData(data);
    marketRef.current = data;
    setConnected(true); // Simular conexión para datos sintéticos
  }, []);

  // Conexión WebSocket para datos en tiempo real
  const fetchHistorical = useCallback(async (limit = 500) => {
    try {
      // Usar nuestro proxy del backend en lugar de Binance directamente
      const url = `${process.env.REACT_APP_BACKEND_URL}/api/binance/klines?symbol=${pair}&interval=${timeframe}&limit=${limit}`;
      const resp = await fetch(url);
      if (!resp.ok) throw new Error('Error fetching historical data');
      
      const response = await resp.json();
      if (!response.success) throw new Error(response.error || 'API error');
      
      const mapped = response.data.map(k => ({
        time: k.time,
        open: k.open,
        high: k.high,
        low: k.low,
        close: k.close,
        volume: k.volume,
        timestamp: new Date(k.time).toLocaleString()
      }));

      setMarketData(mapped);
      marketRef.current = mapped;
    } catch (e) {
      console.error('Error fetching historical data:', e);
      // Generar datos sintéticos como fallback
      generateSyntheticData();
    }
  }, [pair, timeframe]);

  // WebSocket para tiempo real (con fallback a datos sintéticos)
  useEffect(() => {
    let ws = null;
    let intervalId = null;
    
    const connect = async () => {
      try {
        if (marketRef.current.length < 30) {
          // Generar datos sintéticos inmediatamente
          console.log('Generating synthetic data...');
          generateSyntheticData();
        }

        // Iniciar actualizaciones sintéticas inmediatamente
        startSyntheticUpdates();
      } catch (e) {
        console.error('Connection setup error:', e);
        generateSyntheticData();
        startSyntheticUpdates();
      }
    };

    const startSyntheticUpdates = () => {
      if (intervalId) clearInterval(intervalId);
      
      // Simular actualizaciones cada 5 segundos
      intervalId = setInterval(() => {
        if (marketRef.current.length > 0) {
          const lastCandle = marketRef.current[marketRef.current.length - 1];
          const now = Date.now();
          
          // Generar nueva vela sintética
          const change = (Math.random() - 0.5) * 500;
          const newCandle = {
            time: now,
            open: lastCandle.close,
            high: lastCandle.close + Math.random() * 200,
            low: lastCandle.close - Math.random() * 200,
            close: Math.max(1000, lastCandle.close + change),
            volume: 100 + Math.random() * 200,
            isFinal: true
          };
          
          newCandle.high = Math.max(newCandle.open, newCandle.close, newCandle.high);
          newCandle.low = Math.min(newCandle.open, newCandle.close, newCandle.low);
          
          updateMarketData(newCandle);
        }
      }, 5000);
      
      setConnected(true); // Mostrar como conectado para datos sintéticos
    };

    const updateMarketData = (candle) => {
      setMarketData(prev => {
        const copy = [...prev];
        if (copy.length && copy[copy.length - 1].time === candle.time) {
          copy[copy.length - 1] = candle;
        } else {
          copy.push(candle);
          if (copy.length > 2000) copy.shift();
        }
        marketRef.current = copy;
        return copy;
      });

      setLastUpdate(new Date());

      // Procesar vela cerrada para predicciones
      if (candle.isFinal) {
        handleClosedCandle(candle);
      }
    };

    const handleClosedCandle = (candle) => {
      const pendingKey = 'ptai_pending_v1';
      const pendingRaw = localStorage.getItem(pendingKey);
      
      if (pendingRaw) {
        try {
          const pending = JSON.parse(pendingRaw);
          setSimulations(prev => prev.map(s => {
            if (s.id !== pending.simId) return s;
            
            const rawPct = ((candle.close - pending.price) / pending.price) * 100;
            const adjPct = s.trend === 'UP' ? rawPct : -rawPct;
            
            return {
              ...s,
              closed: true,
              exitPrice: candle.close,
              exitTime: new Date().toLocaleString(),
              resultPct: adjPct,
              success: adjPct > 0
            };
          }));
          localStorage.removeItem(pendingKey);
        } catch {}
      }

      // Nueva predicción
      const indicators = calculateIndicators(marketRef.current);
      if (indicators) {
        const prediction = makePrediction(indicators);
        if (prediction) {
          setCurrentPrediction(prediction);
          setAnalysis(prediction);
        }
      }
    };

    connect();

    return () => {
      try {
        if (ws) ws.close();
        if (intervalId) clearInterval(intervalId);
      } catch {}
    };
  }, [fetchHistorical, calculateIndicators, makePrediction]);

  // Predicciones automáticas cada 30 segundos
  useEffect(() => {
    const interval = setInterval(() => {
      try {
        const data = marketRef.current || [];
        const indicators = calculateIndicators(data);
        if (!indicators) return;

        const prediction = makePrediction(indicators);
        if (!prediction) return;

        setCurrentPrediction(prediction);
        setAnalysis(prediction);

        const pendingKey = 'ptai_pending_v1';
        if (!localStorage.getItem(pendingKey) && data.length) {
          const last = data[data.length - 1];
          const simId = 'sim_' + Date.now();
          
          const simulation = {
            id: simId,
            timestamp: new Date().toLocaleString(),
            entryPrice: last.close,
            entryTime: last.time,
            trend: prediction.trend,
            probability: prediction.probability,
            confidence: prediction.confidence,
            entryMethod: 'AUTO_30S',
            closed: false
          };

          setSimulations(prev => [...prev, simulation]);
          localStorage.setItem(pendingKey, JSON.stringify({
            prediction,
            price: last.close,
            time: last.time,
            simId
          }));
        }
      } catch (e) {
        console.error('Auto prediction error:', e);
      }
    }, 30000);

    return () => clearInterval(interval);
  }, [calculateIndicators, makePrediction]);

  // Cálculo de estadísticas
  const closedSims = simulations.filter(s => s.closed && typeof s.exitPrice === 'number');
  const wins = closedSims.filter(s => (s.resultPct || 0) > 0).length;
  const losses = closedSims.filter(s => (s.resultPct || 0) <= 0).length;
  const winRate = closedSims.length ? (wins / closedSims.length) * 100 : 0;
  const avgProfit = closedSims.length ? 
    closedSims.reduce((sum, s) => sum + (s.resultPct || 0), 0) / closedSims.length : 0;

  const getTrendIcon = (trend) => {
    switch (trend) {
      case 'UP': return <ArrowUpCircle className="w-5 h-5 text-emerald-400" />;
      case 'DOWN': return <ArrowDownCircle className="w-5 h-5 text-red-400" />;
      default: return <Minus className="w-5 h-5 text-slate-400" />;
    }
  };

  const getTrendColor = (trend) => {
    switch (trend) {
      case 'UP': return 'text-emerald-400';
      case 'DOWN': return 'text-red-400';
      default: return 'text-slate-400';
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-950 via-blue-950 to-slate-900">
      {/* Header */}
      <div className="border-b border-slate-800/50 bg-slate-900/80 backdrop-blur-sm">
        <div className="max-w-7xl mx-auto px-6 py-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-4">
              <div className="flex items-center space-x-2">
                <Brain className="w-8 h-8 text-blue-400" />
                <div>
                  <h1 className="text-2xl font-bold text-white">TradingAI Pro</h1>
                  <p className="text-sm text-slate-400">BTC/USDT • Tiempo Real</p>
                </div>
              </div>
            </div>
            
            <div className="flex items-center space-x-6">
              <div className="flex items-center space-x-2">
                <div className={`w-2 h-2 rounded-full ${connected ? 'bg-emerald-400 animate-pulse' : 'bg-red-400'}`}></div>
                <span className="text-sm text-slate-300">
                  {connected ? 'Conectado' : 'Desconectado'}
                </span>
              </div>
              
              <div className="text-sm text-slate-400">
                Última actualización: {lastUpdate ? lastUpdate.toLocaleTimeString() : '—'}
              </div>
            </div>
          </div>
        </div>
      </div>

      <div className="max-w-7xl mx-auto px-6 py-6">
        {/* Navigation Tabs */}
        <div className="flex space-x-1 bg-slate-800/30 p-1 rounded-xl mb-6">
          {[
            { id: 'live', label: 'Análisis en Vivo', icon: Activity },
            { id: 'predictions', label: 'Predicciones', icon: Target },
            { id: 'stats', label: 'Estadísticas', icon: BarChart3 }
          ].map(tab => {
            const Icon = tab.icon;
            return (
              <button
                key={tab.id}
                onClick={() => setActiveTab(tab.id)}
                className={`flex items-center space-x-2 px-4 py-2 rounded-lg font-medium transition-all duration-200 ${
                  activeTab === tab.id 
                    ? 'bg-blue-600 text-white shadow-lg shadow-blue-600/25' 
                    : 'text-slate-400 hover:text-white hover:bg-slate-700/50'
                }`}
              >
                <Icon className="w-4 h-4" />
                <span>{tab.label}</span>
              </button>
            );
          })}
        </div>

        {/* Content */}
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Chart Section */}
          <div className="lg:col-span-2">
            <div className="bg-slate-800/40 backdrop-blur-sm border border-slate-700/50 rounded-2xl p-6">
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-xl font-semibold text-white flex items-center space-x-2">
                  <BarChart3 className="w-5 h-5 text-blue-400" />
                  <span>Gráfico de Velas Japonesas</span>
                </h2>
                <div className="text-sm text-slate-400">
                  {marketData.length > 0 && `$${marketData[marketData.length - 1]?.close?.toFixed(2) || '—'}`}
                </div>
              </div>
              
              <div 
                ref={containerRef}
                className="w-full rounded-xl overflow-hidden border border-slate-700/30"
                style={{ height: '600px' }}
              />
            </div>
          </div>

          {/* Side Panel */}
          <div className="space-y-6">
            {/* Current Prediction */}
            <div className="bg-slate-800/40 backdrop-blur-sm border border-slate-700/50 rounded-2xl p-6">
              <h3 className="text-lg font-semibold text-white mb-4 flex items-center space-x-2">
                <Zap className="w-5 h-5 text-yellow-400" />
                <span>Predicción Actual</span>
              </h3>
              
              {currentPrediction ? (
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center space-x-2">
                      {getTrendIcon(currentPrediction.trend)}
                      <span className={`font-bold text-lg ${getTrendColor(currentPrediction.trend)}`}>
                        {currentPrediction.trend === 'UP' ? 'ALCISTA' : 
                         currentPrediction.trend === 'DOWN' ? 'BAJISTA' : 'NEUTRAL'}
                      </span>
                    </div>
                    <div className="text-right">
                      <div className="text-sm text-slate-400">Confianza</div>
                      <div className="text-lg font-bold text-blue-400">
                        {(currentPrediction.confidence * 100).toFixed(0)}%
                      </div>
                    </div>
                  </div>

                  <div className="grid grid-cols-2 gap-4">
                    <div className="bg-emerald-900/20 border border-emerald-700/30 rounded-lg p-3">
                      <div className="text-xs text-emerald-400 mb-1">Probabilidad ↗</div>
                      <div className="text-lg font-bold text-emerald-300">
                        {currentPrediction.probability.up}%
                      </div>
                    </div>
                    <div className="bg-red-900/20 border border-red-700/30 rounded-lg p-3">
                      <div className="text-xs text-red-400 mb-1">Probabilidad ↘</div>
                      <div className="text-lg font-bold text-red-300">
                        {currentPrediction.probability.down}%
                      </div>
                    </div>
                  </div>

                  <div>
                    <div className="text-sm text-slate-400 mb-2">Análisis Técnico:</div>
                    <div className="space-y-1">
                      {currentPrediction.reasoning?.slice(0, 4).map((reason, i) => (
                        <div key={i} className="text-xs text-slate-300 bg-slate-700/30 rounded px-2 py-1">
                          • {reason}
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
              ) : (
                <div className="text-center py-8 text-slate-400">
                  <Brain className="w-12 h-12 mx-auto mb-2 animate-pulse" />
                  <p>Analizando mercado...</p>
                </div>
              )}
            </div>

            {/* Quick Stats */}
            <div className="bg-slate-800/40 backdrop-blur-sm border border-slate-700/50 rounded-2xl p-6">
              <h3 className="text-lg font-semibold text-white mb-4 flex items-center space-x-2">
                <PieChart className="w-5 h-5 text-purple-400" />
                <span>Rendimiento</span>
              </h3>
              
              <div className="grid grid-cols-2 gap-4">
                <div className="text-center">
                  <div className="text-2xl font-bold text-emerald-400">{wins}</div>
                  <div className="text-xs text-slate-400">Ganadas</div>
                </div>
                <div className="text-center">
                  <div className="text-2xl font-bold text-red-400">{losses}</div>
                  <div className="text-xs text-slate-400">Perdidas</div>
                </div>
                <div className="text-center">
                  <div className="text-2xl font-bold text-blue-400">{winRate.toFixed(1)}%</div>
                  <div className="text-xs text-slate-400">Win Rate</div>
                </div>
                <div className="text-center">
                  <div className={`text-2xl font-bold ${avgProfit >= 0 ? 'text-emerald-400' : 'text-red-400'}`}>
                    {avgProfit >= 0 ? '+' : ''}{avgProfit.toFixed(2)}%
                  </div>
                  <div className="text-xs text-slate-400">Promedio</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Detailed Content Based on Active Tab */}
        {activeTab === 'predictions' && (
          <div className="mt-6">
            <div className="bg-slate-800/40 backdrop-blur-sm border border-slate-700/50 rounded-2xl p-6">
              <h3 className="text-xl font-semibold text-white mb-6 flex items-center space-x-2">
                <Target className="w-6 h-6 text-blue-400" />
                <span>Historial de Simulaciones</span>
              </h3>
              
              <div className="space-y-3 max-h-96 overflow-y-auto">
                {simulations.slice().reverse().slice(0, 20).map(sim => (
                  <div key={sim.id} className="bg-slate-700/30 border border-slate-600/30 rounded-lg p-4">
                    <div className="flex items-center justify-between">
                      <div className="flex items-center space-x-3">
                        {getTrendIcon(sim.trend)}
                        <div>
                          <div className="font-medium text-white">
                            {sim.trend} • ${sim.entryPrice?.toFixed(2)}
                          </div>
                          <div className="text-sm text-slate-400">{sim.timestamp}</div>
                        </div>
                      </div>
                      
                      <div className="text-right">
                        {sim.closed ? (
                          <div>
                            <div className={`font-bold ${(sim.resultPct || 0) >= 0 ? 'text-emerald-400' : 'text-red-400'}`}>
                              {(sim.resultPct || 0) >= 0 ? '+' : ''}{(sim.resultPct || 0).toFixed(2)}%
                            </div>
                            <div className="text-xs text-slate-400">${sim.exitPrice?.toFixed(2)}</div>
                          </div>
                        ) : (
                          <div className="text-yellow-400 text-sm">En curso...</div>
                        )}
                      </div>
                    </div>
                    
                    <div className="mt-2 text-xs text-slate-400">
                      ↗ {sim.probability?.up}% • ↘ {sim.probability?.down}%
                    </div>
                  </div>
                ))}
                
                {simulations.length === 0 && (
                  <div className="text-center py-8 text-slate-400">
                    <Target className="w-12 h-12 mx-auto mb-2" />
                    <p>No hay simulaciones aún</p>
                  </div>
                )}
              </div>
            </div>
          </div>
        )}

        {activeTab === 'stats' && (
          <div className="mt-6 grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="bg-slate-800/40 backdrop-blur-sm border border-slate-700/50 rounded-2xl p-6">
              <h3 className="text-xl font-semibold text-white mb-6">Métricas Generales</h3>
              <div className="space-y-4">
                <div className="flex justify-between items-center">
                  <span className="text-slate-400">Total Simulaciones:</span>
                  <span className="text-white font-bold">{simulations.length}</span>
                </div>
                <div className="flex justify-between items-center">
                  <span className="text-slate-400">Simulaciones Cerradas:</span>
                  <span className="text-white font-bold">{closedSims.length}</span>
                </div>
                <div className="flex justify-between items-center">
                  <span className="text-emerald-400">Operaciones Ganadoras:</span>
                  <span className="text-emerald-400 font-bold">{wins}</span>
                </div>
                <div className="flex justify-between items-center">
                  <span className="text-red-400">Operaciones Perdedoras:</span>
                  <span className="text-red-400 font-bold">{losses}</span>
                </div>
              </div>
            </div>

            <div className="bg-slate-800/40 backdrop-blur-sm border border-slate-700/50 rounded-2xl p-6">
              <h3 className="text-xl font-semibold text-white mb-6">Análisis de Rendimiento</h3>
              <div className="space-y-4">
                <div className="flex justify-between items-center">
                  <span className="text-slate-400">Tasa de Éxito:</span>
                  <span className="text-blue-400 font-bold">{winRate.toFixed(2)}%</span>
                </div>
                <div className="flex justify-between items-center">
                  <span className="text-slate-400">Ganancia Promedio:</span>
                  <span className={`font-bold ${avgProfit >= 0 ? 'text-emerald-400' : 'text-red-400'}`}>
                    {avgProfit >= 0 ? '+' : ''}{avgProfit.toFixed(2)}%
                  </span>
                </div>
                {closedSims.length > 0 && (
                  <>
                    <div className="flex justify-between items-center">
                      <span className="text-slate-400">Mejor Operación:</span>
                      <span className="text-emerald-400 font-bold">
                        +{Math.max(...closedSims.map(s => s.resultPct || 0)).toFixed(2)}%
                      </span>
                    </div>
                    <div className="flex justify-between items-center">
                      <span className="text-slate-400">Peor Operación:</span>
                      <span className="text-red-400 font-bold">
                        {Math.min(...closedSims.map(s => s.resultPct || 0)).toFixed(2)}%
                      </span>
                    </div>
                  </>
                )}
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default App;