export function sma(values: number[], period: number){ if (values.length<period) return NaN; const slice = values.slice(-period); return slice.reduce((a,b)=>a+b,0)/period; }
export function rsi(values: number[], period=14){ if (values.length<period+1) return NaN; let gains=0, losses=0; for (let i=values.length-period;i<values.length;i++){ const diff = values[i]-values[i-1]; if (diff>=0) gains+=diff; else losses-=diff; } if (losses===0) return 100; const rs=gains/losses; return 100 - (100/(1+rs)); }
export function macd(values:number[],fast=12,slow=26,signal=9){ if (values.length<slow) return { macd: NaN, signal: NaN }; const ema = (vals:number[], p:number) => { if (vals.length<p) return NaN; const k=2/(p+1); let e=vals[0]; for (let i=1;i<vals.length;i++) e = vals[i]*k + e*(1-k); return e; }; const macdLine = ema(values, fast) - ema(values, slow); const signalLine = ema([...(new Array(values.length-1)).fill(0), macdLine], signal); return { macd: macdLine, signal: signalLine }; }
export function bollinger(values:number[], period=20, k=2){ if (values.length<period) return { upper: NaN, lower: NaN }; const slice = values.slice(-period); const mean = slice.reduce((a,b)=>a+b,0)/period; const variance = slice.reduce((a,b)=>a+(b-mean)**2,0)/period; const std = Math.sqrt(variance); return { upper: mean + k*std, lower: mean - k*std }; }
export function toCloses(candles:any[]){ return candles.map(c=>c.close); }
